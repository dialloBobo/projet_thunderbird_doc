<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: mail_sort/mailSort.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: mail_sort/mailSort.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { extractNodeNames } from '../mind_map/saveMindMap.js';
import { getSavedMindMap } from "../mind_map/loadMindMap.js";
import { getAllTags } from "./extractTerminalNodesName.js";
import { emptyTrashFolder } from "./trash/trash.js";

let accounts;
let folderNodeMap = {};
let allCopiedIds = new Set();



/**
 * Initialise et exÃ©cute le tri des mails en fonction de la carte mentale et des tags.
 * Cette fonction vÃ©rifie la cohÃ©rence entre la structure des dossiers, la carte mentale
 * et les tags, puis trie les mails en les classant dans les dossiers appropriÃ©s.
 * 
 * @async
 * @returns {Promise&lt;void>}
 */

// Fonction principale qui initialise le systÃ¨me et lance la rÃ©cupÃ©ration des mails
export async function executeMailSort() {

    await initAccount(); // RÃ©cupÃ©ration des comptes mail disponibles
    const mindMailFolder = await initMainFolder();

    // VÃ©rification de la correspondance de structure
    const mindMapTree = extractNodeNames(await getSavedMindMap());
    mindMapTree["Non ClassÃ©"] = {};

    const currentFolderTree = await getCurrentMindMailTree(mindMailFolder);

    const isSameStructure = compareFolderTrees(mindMapTree, currentFolderTree);

    // RÃ©cupÃ¨re les tags actuels
    const currentTags = await getAllTags();

    // Compare les tags stockÃ©s avec les nouveaux tags
    const savedTags = await getSavedTags();
    const isSameTags = compareTags(savedTags || [], currentTags);

    if (!isSameStructure || !isSameTags) {
        console.warn("DiffÃ©rence dÃ©tectÃ©e entre la carte mentale, les dossiers et/ou les tags. Nettoyage en cours...");
        await clearStoredFoldersData();
        await emptyTrashFolder();
        allCopiedIds = new Set();
        await initAccount();
        await initMainFolder(); // CrÃ©ation du dossier principal "MindMail"
        await saveTags(currentTags); // Sauvegarde des nouveaux tags
        await createSubFolder(); // CrÃ©ation de la structure de dossiers en fonction de la carte mentale
    } else {
        console.log("[STATUT] Structure MindMail valide");
        console.log(`[DEBUG] Tags stockÃ©s : ${JSON.stringify(savedTags)}`);
        console.log(`[DEBUG] Tags actuels : ${JSON.stringify(currentTags)}`);
        await loadAllPreviouslyCopiedIds();
        console.log(`[DEBUG] IDs en mÃ©moire aprÃ¨s chargement : ${allCopiedIds.size}`);
    }

    // Chargement de la carte mentale sauvegardÃ©e
    const mindMapData = await getSavedMindMap();
    if (!mindMapData || !mindMapData.nodeData) return;

    // RÃ©cupÃ¨re tous les mails une seule fois pour Ã©viter les appels redondants
    const allMails = await getAllMails();
    console.log(`Nombre total de mails rÃ©cupÃ©rÃ©s : ${allMails.length}`);

    // Lance le parcours de la carte mentale pour trier les mails
    await mailSort(mindMapData, allMails);
}


// RÃ©cupÃ¨re la liste des comptes de messagerie configurÃ©s
export async function initAccount() {
    accounts = await browser.accounts.list();
    console.log(`Nombre de comptes trouvÃ©s : ${accounts.length}`);
    for (let account of accounts) {
        console.log(account.name); 
    }       
}


/**
 * RÃ©cupÃ¨re tous les mails envoyÃ©s et reÃ§us dans tous les comptes configurÃ©s.
 * Parcourt rÃ©cursivement les dossiers pour rÃ©cupÃ©rer les messages.
 * 
 * @async
 * @returns {Promise&lt;Array&lt;Object>>} Une liste contenant tous les messages rÃ©cupÃ©rÃ©s.
 */


async function getAllMails() {
    const allMails = [];

    console.log("ðŸ“¥ðŸ“¤ DÃ©but de la rÃ©cupÃ©ration des mails envoyÃ©s et reÃ§us...");

    // Fonction rÃ©cursive pour traiter les dossiers
    async function processFolders(folders) {
        for (let folder of folders) {
            const name = folder.name.toLowerCase();
            const path = folder.path.toLowerCase();

            console.log(` â†’ Dossier trouvÃ© : ${folder.name} (chemin: ${folder.path})`);

            const isSent =
                name.includes("envoyÃ©") || name.includes("sent") || path.includes("sent") || path.includes("envoy");

            const isInbox =
                name.includes("courrier entrant") || path === "/inbox";

            if (isSent || isInbox) {
                console.log(`   âœ… Dossier identifiÃ© comme ${isSent ? "d'envoi" : "de rÃ©ception"} : ${folder.name}`);

                try {
                    let page = await messenger.messages.list(folder.id);
                    let messageList = page.messages || [];

                    console.log(`   ðŸ“© ${messageList.length} message(s) dans la premiÃ¨re page de ${folder.name}`);
                    allMails.push(...messageList);

                    while (page.id) {
                        page = await messenger.messages.continueList(page.id);
                        messageList = page.messages || [];

                        console.log(`   âž• ${messageList.length} message(s) supplÃ©mentaire(s) via pagination`);
                        allMails.push(...messageList);
                    }
                } catch (error) {
                    console.warn(`   âš ï¸ Erreur lors de la rÃ©cupÃ©ration des mails dans ${folder.name}:`, error);
                }
            } else {
                console.log("   â›” Dossier ignorÃ©");
            }

            // RÃ©cursion sur les sous-dossiers
            if (folder.subFolders &amp;&amp; folder.subFolders.length > 0) {
                await processFolders(folder.subFolders);
            }
        }
    }

    // Parcours des comptes
    for (let account of accounts) {
        console.log(`\nðŸ§¾ Compte : ${account.name} (${account.id})`);
        const fullAccount = await browser.accounts.get(account.id);
        await processFolders(fullAccount.folders);
    }

    console.log(`\nðŸ“¬ Total de messages rÃ©cupÃ©rÃ©s (envoyÃ©s + reÃ§us) : ${allMails.length}`);
    return allMails;
}


/**
 * Trie les mails en fonction de la carte mentale sauvegardÃ©e et des tags.
 * Les mails sont copiÃ©s dans les dossiers correspondant aux tags dÃ©tectÃ©s,
 * ou dans le dossier "Non ClassÃ©" s'ils ne correspondent Ã  aucun tag.
 * 
 * @async
 * @param {Object} mindMapData DonnÃ©es de la carte mentale sauvegardÃ©e.
 * @param {Array&lt;Object>} allMails Liste complÃ¨te des mails Ã  trier.
 * @returns {Promise&lt;void>}
 */

async function mailSort(mindMapData, allMails) {
    console.log("Lancement du tri des mails...");
    const accounts = await browser.accounts.list();
    const lastAccount = accounts[accounts.length - 1]; // "Dossiers locaux"
    const accountName = lastAccount.name;

    const folderNodeMap = {};
    async function buildFolderMap(folder, prefix = folder.name) {
        const path = `${accountName}/${prefix}`;
        folderNodeMap[path] = folder;

        if (folder.subFolders) {
            for (const sub of folder.subFolders) {
                await buildFolderMap(sub, `${prefix}/${sub.name}`);
            }
        }
    }

    for (const folder of lastAccount.folders) {
        await buildFolderMap(folder);
    }

    console.log("Arborescence des dossiers indexÃ©e:");
    for (const key in folderNodeMap) {
        console.log(`   - ${key}`);
    }

    const tagNodeMap = indexNodesByTags(mindMapData.nodeData);
    const allTagSet = new Set(tagNodeMap.keys());

    console.log("Index des tags construit:");
    for (const [tag, paths] of tagNodeMap.entries()) {
        console.log(`   - ${tag}: ${Array.from(paths).join(", ")}`);
    }

    const normalize = str => str?.toLowerCase().trim() || "";
    const copiedCache = {};
    const fullPathNonClasse = `${accountName}/MindMail/Non ClassÃ©`;
    const folderNonClasse = folderNodeMap[fullPathNonClasse];

    if (!folderNonClasse) {
        console.warn(`Dossier 'Non ClassÃ©' introuvable Ã  "${fullPathNonClasse}"`);
    }

    for (const mail of allMails) {
        const subject = normalize(mail.subject);
        const author = normalize(mail.author);

        console.log(`[TRAITEMENT] VÃ©rification du mail ${mail.id}...`);
        if (allCopiedIds.has(mail.id)) {
            console.log(`[SKIP] Mail ${mail.id} dÃ©jÃ  traitÃ©`);
            continue;
        }

        let bodyText = "";
        try {
            const fullMessage = await browser.messages.getFull(mail.id);
            for (const part of fullMessage.parts || []) {
                if (part.contentType === "text/plain" &amp;&amp; part.body) {
                    bodyText = normalize(part.body);
                    break;
                }
            }
        } catch (err) {
        }

        const matchedPaths = new Set();

        for (const [nodePath, tagInfo] of tagNodeMap.entries()) {
            const { inheritedTags, ownTags, isDirectChildOfRoot } = tagInfo;

            const hasOwnTagMatch = [...ownTags].some(tag =>
                subject.includes(tag) || author.includes(tag) || bodyText.includes(tag)
            );

            let match = false;

            if (isDirectChildOfRoot) {
                match = hasOwnTagMatch;
            } else {
                const hasInheritedMatch = [...inheritedTags].some(tag =>
                    subject.includes(tag) || author.includes(tag) || bodyText.includes(tag)
                );
                match = hasOwnTagMatch &amp;&amp; hasInheritedMatch;
            }

            if (match) {
                matchedPaths.add(nodePath);
            }
        }


        // Aucune correspondance avec un tag : copier dans "Non ClassÃ©"
        if (matchedPaths.size === 0) {
            if (!folderNonClasse) {
                continue;
            }

            const nodePath = "MindMail/Non ClassÃ©";
            if (!copiedCache[nodePath]) {
                const loadedIds = await loadCopiedMailIds(nodePath);
                console.log(`Mails dÃ©jÃ  copiÃ©s pour ${nodePath} : ${loadedIds.length}`);

                copiedCache[nodePath] = new Set(loadedIds);
            }

            if (copiedCache[nodePath].has(mail.id)) {
                continue;
            }

            try {
                console.log(`Non ClassÃ© -> ${mail.subject} - &lt;${mail.author}>`)
                await browser.messages.copy([mail.id], folderNonClasse.id);
                await saveCopiedMailId(nodePath, mail.id);
                copiedCache[nodePath].add(mail.id);
                allCopiedIds.add(mail.id);
                await storeNotification({
                    subject: mail.subject,
                    author: mail.author,
                    messageId: mail.id,
                    date: mail.date
                });
            } catch (err) {
                console.error(`Erreur de copie de "${mail.subject}" - &lt;${mail.author}> dans "Non ClassÃ©": ${err}`);
            }
            continue;
        }

        // Sinon, on copie dans tous les dossiers liÃ©s aux tags
        for (const nodePath of matchedPaths) {
            const fullPath = `${accountName}/${nodePath}`;
            const folder = folderNodeMap[fullPath];

            if (!folder) {
                continue;
            }

            if (!copiedCache[nodePath]) {
                const loadedIds = await loadCopiedMailIds(nodePath);
                copiedCache[nodePath] = new Set(loadedIds);
            }

            if (copiedCache[nodePath].has(mail.id)) {
                continue;
            }

            console.log("Chargement des mails dÃ©jÃ  copiÃ©s pour tous les dossiers :");
            for (const path in copiedCache) {
                console.log(`${path} -> ${copiedCache[path].size} mails`);
            }


            try {
                console.log(`${nodePath} -> ${mail.subject} - &lt;${mail.author}>`)
                await browser.messages.copy([mail.id], folder.id);
                await saveCopiedMailId(nodePath, mail.id);
                copiedCache[nodePath].add(mail.id);
                allCopiedIds.add(mail.id);
            } catch (e) {
                console.error(`Erreur de copie de "${mail.subject}" - &lt;${mail.author}> dans "${nodePath}":`, e);
            }
        }
    }
    console.log("Tous les mails ont Ã©tÃ© triÃ©s.");
}


/**
 * Indexe les nÅ“uds d'une carte mentale par leurs tags.
 * 
 * @param {Object} node - Le nÅ“ud courant de la carte mentale.
 * @param {string} path - Chemin courant dans l'arborescence (ex: "MindMail/Noeud1").
 * @param {Map} tagMap - Map qui associe un chemin Ã  ses tags hÃ©ritÃ©s et propres.
 * @param {boolean} isRoot - Indique si on est au nÅ“ud racine (MindMail).
 * @param {Set} inheritedTags - Tags hÃ©ritÃ©s des nÅ“uds parents.
 * @param {boolean} isDirectChild - Indique si le nÅ“ud est un enfant direct de la racine.
 * @returns {Map} tagMap mise Ã  jour avec les tags de chaque nÅ“ud.
 */
function indexNodesByTags(node, path = "MindMail", tagMap = new Map(), isRoot = true, inheritedTags = new Set(), isDirectChild = false) {
    // Fonction pour normaliser un tag (trim + minuscules)
    const normalize = tag => tag.trim().toLowerCase();

    // DÃ©termine le chemin complet du nÅ“ud courant
    const nodePath = isRoot ? path : `${path}/${node.topic}`.replace(/\/+/, '/');

    // RÃ©cupÃ¨re les tags propres au nÅ“ud, si on n'est pas Ã  la racine
    const ownTags = new Set();
    if (!isRoot &amp;&amp; Array.isArray(node.tags)) {
        for (const rawTag of node.tags) {
            ownTags.add(normalize(rawTag));
        }
    }

    // Stocke dans la map les tags hÃ©ritÃ©s et propres de ce nÅ“ud, sauf pour la racine
    if (!isRoot) {
        tagMap.set(nodePath, {
            inheritedTags: new Set(inheritedTags), // copie des tags hÃ©ritÃ©s
            ownTags, // tags propres au nÅ“ud
            isDirectChildOfRoot: isDirectChild // si enfant direct de la racine
        });
    }

    // PrÃ©pare l'ensemble des tags hÃ©ritÃ©s pour les enfants en ajoutant les propres
    const nextInherited = new Set(inheritedTags);
    ownTags.forEach(tag => nextInherited.add(tag));

    // Parcourt rÃ©cursivement les enfants du nÅ“ud courant
    if (node.children &amp;&amp; node.children.length > 0) {
        for (const child of node.children) {
            // Si on est Ã  la racine, les enfants sont des enfants directs
            indexNodesByTags(child, nodePath, tagMap, false, nextInherited, isRoot);
        }
    }

    return tagMap;
}


/**
 * CrÃ©e le dossier racine "MindMail" dans un compte mail donnÃ©, s'il n'existe pas dÃ©jÃ .
 * 
 * @param {string} mailAdress - Adresse mail du compte (optionnel, par dÃ©faut le dernier compte).
 * @returns {Object|null} Le dossier MindMail crÃ©Ã© ou existant, ou null en cas d'erreur.
 */
async function initMainFolder(mailAdress = "none") {
    let account; 

    // SÃ©lection du compte : par dÃ©faut dernier compte sinon par adresse
    if (mailAdress == "none") account = accounts[accounts.length - 1];
    else {
        for (let acc of accounts) {
            if (acc.name == mailAdress) account = acc;
        }
    }

    if (!account) {
        console.error("Aucun compte valide trouvÃ©.");
        return;
    }

    // RÃ©cupÃ©ration des dossiers du compte complet
    let fullAccount = await browser.accounts.get(account.id);

    // VÃ©rifie si le dossier "MindMail" existe dÃ©jÃ 
    const existingFolder = fullAccount.folders.find(folder => folder.name === "MindMail");

    if (existingFolder) {
        console.log("Le dossier 'MindMail' existe dÃ©jÃ  :", existingFolder.path);
        return existingFolder;
    }

    // Sinon, crÃ©ation du dossier "MindMail" Ã  la racine du compte
    try {
        const folder = await browser.folders.create(account.rootFolder.id, "MindMail");
        console.log("Dossier 'MindMail' crÃ©Ã© :", folder.path, "dans le compte ", account.name);
        return folder;
    } catch (error) {
        console.error("Erreur lors de la crÃ©ation du dossier 'MindMail' :", error);
        return null;
    }
}


/**
 * CrÃ©e rÃ©cursivement les dossiers correspondant Ã  la structure de la carte mentale,
 * dans le compte mail donnÃ©, en ajoutant un dossier "Non ClassÃ©" Ã  la fin.
 * 
 * @param {string} mailAdress - Adresse mail du compte (optionnel, par dÃ©faut dernier compte).
 */
async function createSubFolder(mailAdress = "none") {
    let account;

    // SÃ©lection du compte
    if (mailAdress === "none") {
        account = accounts[accounts.length - 1];
    } else {
        account = accounts.find(acc => acc.name === mailAdress);
        if (!account) {
            console.error("Aucun compte ne correspond Ã  l'adresse entrÃ©e !");
            return;
        }
    }

    // RÃ©cupÃ¨re le dossier MindMail dans ce compte
    const mindMailFolder = await getMindMailFolder(account);
    if (!mindMailFolder) {
        console.error("Dossier 'MindMail' introuvable !");
        return;
    }

    // Construit la structure arborescente de la carte mentale (sous forme d'objet)
    const tree = extractNodeNames(await getSavedMindMap());

    // Ajoute un dossier "Non ClassÃ©" pour les mails non triÃ©s
    tree["Non ClassÃ©"] = {};
    console.log("Arborescence Ã  crÃ©er :", tree);

    // CrÃ©ation rÃ©cursive des dossiers dans Thunderbird, et stockage des IDs
    folderNodeMap = await createMindMapFolders(tree, mindMailFolder.id);
}


/**
 * CrÃ©e rÃ©cursivement les dossiers Ã  partir d'un objet arborescent.
 * 
 * @param {Object} tree - Objet reprÃ©sentant l'arborescence Ã  crÃ©er.
 * @param {string} parentFolderId - ID du dossier parent dans Thunderbird.
 * @param {string} parentPath - Chemin relatif pour constituer les clÃ©s de mapping.
 * @returns {Object} Map entre chemin complet et ID de dossier Thunderbird.
 */
async function createMindMapFolders(tree, parentFolderId, parentPath = "") {
    const folderMap = {};

    // RÃ©cupÃ¨re les sous-dossiers existants pour Ã©viter doublons
    const parentInfo = await browser.folders.getSubFolders(parentFolderId);
    const existingNames = parentInfo.map(f => f.name);

    for (let nodeName in tree) {
        // Nettoyage du nom de dossier pour Ã©viter caractÃ¨res invalides
        const safeName = nodeName.replace(/[\\/:"*?&lt;>|]+/g, "_");
        let folderId;
        let newFolder;

        try {
            if (existingNames.includes(safeName)) {
                // Si dossier existe dÃ©jÃ , rÃ©cupÃ¨re son ID
                const existingFolder = parentInfo.find(f => f.name === safeName);
                folderId = existingFolder.id;
                console.log(`Le dossier '${safeName}' existe dÃ©jÃ .`);
            } else {
                // Sinon, crÃ©ation du dossier
                newFolder = await browser.folders.create(parentFolderId, safeName);
                folderId = newFolder.id;
                console.log("Dossier crÃ©Ã© :", newFolder.path);
            }

            // Construit le chemin complet dans la map
            const fullPath = `MindMail/${parentPath}${nodeName}`;
            folderMap[fullPath] = folderId;
            if (newFolder) folderMap[newFolder.path] = folderId;

            // Appel rÃ©cursif pour les enfants
            const children = tree[nodeName];
            if (children &amp;&amp; Object.keys(children).length > 0) {
                const subMap = await createMindMapFolders(children, folderId, `${parentPath}${nodeName}/`);
                Object.assign(folderMap, subMap);
            }

        } catch (err) {
            console.error(`Erreur crÃ©ation dossier '${nodeName}':`, err);
        }
    }

    return folderMap;
}


/**
 * Recherche dans un compte mail le dossier "MindMail".
 * 
 * @param {Object} account - Compte mail Thunderbird.
 * @returns {Object|null} Le dossier "MindMail" ou null s'il n'existe pas.
 */
async function getMindMailFolder(account) {
    let fullAccount = await browser.accounts.get(account.id);
    let rootFolders = fullAccount.folders;

    for (let folder of rootFolders) {
        if (folder.name === "MindMail") {
            return folder;
        }
    }

    console.warn("Le dossier 'MindMail' n'a pas Ã©tÃ© trouvÃ©.");
    return null;
}


/**
 * Stocke une notification dans le stockage local.
 * 
 * @param {Object} notification - Objet notification Ã  stocker.
 */
async function storeNotification(notification) {
    let notifications = await browser.storage.local.get('notifications');
    notifications = notifications.notifications || [];
    notifications.push(notification);
    await browser.storage.local.set({notifications});
}


/**
 * Supprime toutes les notifications du stockage local et vide l'affichage.
 */
async function clearNotifications() {
    await browser.storage.local.remove('notifications');
    document.getElementById('notifications').innerHTML = '';
    console.log("All notifications removed from local storage.");
}


/**
 * Charge depuis le stockage local tous les IDs de mails dÃ©jÃ  copiÃ©s dans tous les dossiers.
 */
async function loadAllPreviouslyCopiedIds() {
    console.log("[DEBUG] Chargement des IDs prÃ©cÃ©demment copiÃ©s...");
    const allData = await browser.storage.local.get(null);
    let totalLoaded = 0;
    for (const [key, value] of Object.entries(allData)) {
        if (key.startsWith("copied_") &amp;&amp; Array.isArray(value)) {
            console.log(`[DEBUG] Dossier trouvÃ© : ${key} (${value.length} IDs)`);
            totalLoaded += value.length;
            for (const id of value) {
                allCopiedIds.add(id);
            }
        }
    }
    console.log(`[DEBUG] Total IDs chargÃ©s depuis le stockage : ${totalLoaded}`);
}


/**
 * Sauvegarde l'ID d'un mail dÃ©placÃ© dans le stockage local, sous la clÃ© du chemin de dossier.
 * 
 * @param {string} nodePath - Chemin complet du dossier.
 * @param {string} mailId - ID du mail Ã  sauvegarder.
 */
export async function saveCopiedMailId(nodePath, mailId) {
    const key = `copied_${encodeURIComponent(nodePath)}`;
    const result = await browser.storage.local.get(key);
    const existing = result[key] || [];
    if (!existing.includes(mailId)) {
        existing.push(mailId);
        await browser.storage.local.set({ [key]: existing });
    }
    console.log(`[SAUVEGARDE] Stockage ID ${mailId} pour ${nodePath}`);
}


/**
 * Charge les IDs de mails dÃ©jÃ  copiÃ©s pour un dossier donnÃ©.
 * 
 * @param {string} nodePath - Chemin complet du dossier.
 * @returns {Array} Liste des IDs de mails.
 */
export async function loadCopiedMailIds(nodePath) {
    const key = `copied_${encodeURIComponent(nodePath)}`;
    const result = await browser.storage.local.get(key);
    return result[key] || [];
}


/**
 * Supprime le dossier "MindMail" et toutes les donnÃ©es associÃ©es dans le stockage local.
 */
export async function clearStoredFoldersData() {
    try {
        console.log("Suppression du dossier 'MindMail'...");

        const accounts = await browser.accounts.list();
        const account = accounts[accounts.length - 1];
        const mindMailFolder = account.folders.find(f => f.name === "MindMail");

        if (!mindMailFolder) {
            console.log("Le dossier 'MindMail' n'existe pas.");
            return;
        }

        // Supprime le dossier "MindMail"
        await browser.folders.delete(mindMailFolder.id);
        console.log("Dossier 'MindMail' supprimÃ©.");

        // Supprime toutes les clÃ©s "copied_" dans le stockage local
        const allData = await browser.storage.local.get(null);
        const keysToDelete = Object.keys(allData).filter(key => key.startsWith("copied_"));
        for (let key of keysToDelete) {
            await browser.storage.local.remove(key);
            console.log(`DonnÃ©es supprimÃ©es pour le dossier : ${key}`);
        }

        await clearNotifications();
        console.log("Stockage local supprimÃ©.");

    } catch (error) {
        console.error("Erreur lors de la suppression :", error);
    }
}


/**
 * DÃ©place un mail d'un dossier source vers un dossier cible dans Thunderbird.
 * 
 * @param {string} mailId - ID du mail Ã  dÃ©placer.
 * @param {string} sourcePath - Chemin complet du dossier source.
 * @param {string} targetPath - Chemin complet du dossier cible.
 */
export async function moveMailToFolder(mailId, sourcePath, targetPath) {
    // RÃ©cupÃ¨re les IDs des dossiers dans la map globale
    const sourceFolderId = folderNodeMap[sourcePath];
    const targetFolderId = folderNodeMap[targetPath];
    console.log("Source folderId:", sourceFolderId);
    console.log("Target folderId:", targetFolderId);

    if (!sourceFolderId || !targetFolderId) {
        console.error("Le dossier source ou cible est introuvable !");
        console.log("sourceFolderId:", sourceFolderId);
        console.log("targetFolderId:", targetFolderId);
        return;
    }

    try {
        // RÃ©cupÃ¨re tous les messages dans le dossier source
        const sourceMessages = await getAllMessagesInFolder(sourceFolderId);

        // Cherche le mail dans le dossier source
        const mail = sourceMessages.find(msg => msg.id === mailId);

        if (!mail) {
            console.warn(`Le mail d'ID ${mailId} n'est pas dans le dossier source.`);
            return;
        }

        // VÃ©rifie la correspondance d'ID
        if (mailId !== mail.id) {
            
            console.warn(`L'ID du mail trouvÃ© (${mail.id}) ne correspond pas Ã  l'ID recherchÃ© (${mailId}).`);
            return;
        }

        // DÃ©placement du mail
        const result = await browser.messages.move([mailId], targetFolderId);
        const movedMail = result?.messages?.[0];

        if (!movedMail) {
            console.warn("Le mail a Ã©tÃ© dÃ©placÃ© mais aucune info nâ€™a Ã©tÃ© retournÃ©e par lâ€™API.");
        } else {
            // Met Ã  jour la mÃ©moire locale avec le nouvel ID
            await saveCopiedMailId(targetPath, movedMail.id);
            allCopiedIds.delete(mailId);
            allCopiedIds.add(movedMail.id);

            console.log(`Mail dÃ©placÃ© vers '${targetPath}'`);

            // Supprime l'ancien ID de la liste du dossier source
            await removeCopiedMailId(sourcePath, mailId);
        }

    } catch (err) {
        console.error("Erreur dÃ©placement mail :", err);
    }
}


// Supprime un ID de mail depuis le fichier de suivi associÃ© Ã  un dossier donnÃ©
async function removeCopiedMailId(path, idMail) {
    try {
        const storageKey = `copied-${path}`;
        const result = await browser.storage.local.get(storageKey);
        const existingIds = result[storageKey] || [];

        const updatedIds = existingIds.filter(id => id !== idMail);

        await browser.storage.local.set({ [storageKey]: updatedIds });
        console.log(`ID supprimÃ© du stockage local pour '${path}'`);
    } catch (err) {
        console.error(`Erreur suppression ID pour '${path}' :`, err);
    }
}


async function getAllMessagesInFolder(folderId) {
    let allMessages = [];
    let result = await browser.messages.query({ folderId });
    allMessages.push(...result.messages);

    while (result.id) {
        result = await browser.messages.continueList(result.id);
        allMessages.push(...result.messages);
    }

    // Format date without timezone
    return allMessages.map(msg => {
        const dateObj = new Date(msg.date);
        const formattedDate = dateObj.toString().replace(/\s*\([^)]*\)/, '');
        return {
            ...msg,
            date: formattedDate
        };
    });
}


async function getCurrentMindMailTree(mindMailFolder) {
    const buildTree = async (folder) => {
        const children = await browser.folders.getSubFolders(folder.id);
        const tree = {};
        for (const child of children) {
            tree[child.name] = await buildTree(child); // rÃ©cursif
        }
        return tree;
    };

    return await buildTree(mindMailFolder);
}

// Comparer les arbres entre deux nÅ“uds
function compareFolderTrees(tree1, tree2) {
    const keys1 = Object.keys(tree1);
    const keys2 = Object.keys(tree2);

    if (keys1.length !== keys2.length) return false;

    for (const key of keys1) {
        if (!keys2.includes(key)) return false;
        if (!compareFolderTrees(tree1[key], tree2[key])) return false;
    }
    return true;
}


// Fonction pour rÃ©cupÃ©rer les tags prÃ©cÃ©demment stockÃ©s
async function getSavedTags() {
    const result = await browser.storage.local.get("tagsHierarchy");
    return result.tagsHierarchy ? JSON.parse(result.tagsHierarchy) : null;
}


// Fonction pour sauvegarder la nouvelle hiÃ©rarchie des tags
async function saveTags(tagsHierarchy) {
    await browser.storage.local.set({ tagsHierarchy: JSON.stringify(tagsHierarchy) });
}


// Fonction de comparaison des hiÃ©rarchies de tags
function compareTags(oldTags, newTags) {
    // Si les tailles sont diffÃ©rentes, les tags ont changÃ©
    if (oldTags.length !== newTags.length) return false;

    // Comparer chaque tag
    for (let i = 0; i &lt; oldTags.length; i++) {
        const oldTag = oldTags[i];
        const newTag = newTags[i];
        if (oldTag.node !== newTag.node || !arraysEqual(oldTag.tags, newTag.tags)) {
            return false;
        }
    }

    return true;
}


// Fonction utilitaire pour comparer des tableaux (tags)
function arraysEqual(arr1, arr2) {
    if (arr1.length !== arr2.length) return false;
    for (let i = 0; i &lt; arr1.length; i++) {
        if (arr1[i] !== arr2[i]) return false;
    }
    return true;
}

// Fonction interface menu ////////////////////////////////////////////////////////////////

/**
 * RÃ©cupÃ¨re tous les mails d'un dossier spÃ©cifique nommÃ© `folderName` sous le dossier racine "MindMail"
 * dans tous les comptes configurÃ©s dans Thunderbird.
 *
 * @param {string} folderName - Le nom du dossier dans "MindMail" dont on veut rÃ©cupÃ©rer les mails.
 * @returns {Promise&lt;Array>} - Une promesse qui rÃ©sout avec une liste d'objets mails contenant 
 *                             sujet, auteur, id, date, indicateur si le mail est envoyÃ©, 
 *                             et info du dossier (accountId, chemin).
 */

export async function getMailsFromFolder(folderName) {
    const results = [];
    // RÃ©cupÃ¨re la liste des comptes mail configurÃ©s dans Thunderbird
    const accounts = await browser.accounts.list();

    // Parcours chaque compte
    for (const account of accounts) {
        // RÃ©cupÃ¨re les dossiers racines du compte (ex: inbox, drafts, etc.)
        const rootFolders = account.folders || [];

        // Cherche dans ces dossiers racines celui qui s'appelle "MindMail"
        for (const folder of rootFolders) {
            if (folder.name === "MindMail") {
                // Recherche rÃ©cursive du dossier cible par nom dans les sous-dossiers de "MindMail"
                const match = await findFolderIdByName(folder.subFolders, folderName);

                if (match) {
                    try {
                        // RÃ©cupÃ¨re la premiÃ¨re page de messages dans le dossier trouvÃ©
                        let page = await messenger.messages.list(match);

                        // Parcourt toutes les pages de messages tant qu'il y en a
                        while (page) {
                            const messages = page.messages || [];

                            // Pour chaque message, extrait les infos utiles
                            for (let msg of messages) {
                                // DÃ©termine si le message est un mail envoyÃ© (dossier envoyÃ©s ou auteur = compte)
                                const isSent = msg.folder?.path?.toLowerCase().includes("envoy") ||
                                               msg.author?.includes(account.name);

                                results.push({
                                    subject: msg.subject,
                                    author: msg.author,
                                    id: msg.id,
                                    date: msg.date,
                                    isSent: !!isSent,
                                    folderId: {
                                        accountId: account.id,
                                        path: folder.path
                                    }
                                });
                            }

                            // Si la page contient un id de page suivante, on la rÃ©cupÃ¨re, sinon on sort
                            if (page.id) {
                                page = await messenger.messages.continueList(page.id);
                            } else {
                                break;
                            }
                        }

                    } catch (e) {
                        // En cas d'erreur lors de la lecture des messages, on log la cause
                        console.warn(`âŒ Impossible de lire le dossier ${folder.name} :`, e);
                    }
                }
            }
        }
    }

    // Trie les messages par date dÃ©croissante (du plus rÃ©cent au plus ancien)
    results.sort((a, b) => new Date(b.date) - new Date(a.date));
    return results;
}


/**
 * Recherche rÃ©cursive d'un dossier par son nom dans une liste de dossiers,
 * retourne un objet contenant l'accountId et le chemin complet du dossier trouvÃ©.
 * 
 * @param {Array} folders - Liste des dossiers Ã  parcourir
 * @param {string} name - Nom du dossier Ã  trouver (insensible Ã  la casse)
 * @returns {Promise&lt;{accountId: string, path: string} | null>} - L'objet du dossier trouvÃ© ou null si non trouvÃ©
 */
async function findFolderIdByName(folders, name) {
    for (let folder of folders) {
        // VÃ©rifie si le nom du dossier correspond
        if (folder.name.toLowerCase() === name.toLowerCase()) {
            return { accountId: folder.accountId, path: folder.path };
        }
    
        // Recherche rÃ©cursive dans les sous-dossiers
        if (folder.subFolders &amp;&amp; folder.subFolders.length > 0) {
            const found = await findFolderIdByName(folder.subFolders, name);
            if (found) return found;
        }
    }
    // Retourne null si aucun dossier correspondant n'a Ã©tÃ© trouvÃ©
    return null;
}


export { folderNodeMap, createMindMapFolders, getMindMailFolder, getAllMessagesInFolder};</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#clearNotifications">clearNotifications</a></li><li><a href="global.html#clearStoredFoldersData">clearStoredFoldersData</a></li><li><a href="global.html#collectMessages">collectMessages</a></li><li><a href="global.html#createFolderSelect">createFolderSelect</a></li><li><a href="global.html#createMailItem">createMailItem</a></li><li><a href="global.html#createMindMapFolders">createMindMapFolders</a></li><li><a href="global.html#createMoveDialog">createMoveDialog</a></li><li><a href="global.html#createSubFolder">createSubFolder</a></li><li><a href="global.html#emptyTrashFolder">emptyTrashFolder</a></li><li><a href="global.html#executeMailSort">executeMailSort</a></li><li><a href="global.html#extractNodeAndTagNames">extractNodeAndTagNames</a></li><li><a href="global.html#extractNodeNames">extractNodeNames</a></li><li><a href="global.html#findFolderIdByName">findFolderIdByName</a></li><li><a href="global.html#findTextPart">findTextPart</a></li><li><a href="global.html#getAllFolders">getAllFolders</a></li><li><a href="global.html#getAllMails">getAllMails</a></li><li><a href="global.html#getAllSortedMessages">getAllSortedMessages</a></li><li><a href="global.html#getAllTags">getAllTags</a></li><li><a href="global.html#getLeafNodes">getLeafNodes</a></li><li><a href="global.html#getMailsFromFolder">getMailsFromFolder</a></li><li><a href="global.html#getMindMailFolder">getMindMailFolder</a></li><li><a href="global.html#getMindmapPaths">getMindmapPaths</a></li><li><a href="global.html#getRootName">getRootName</a></li><li><a href="global.html#getSavedMindMap">getSavedMindMap</a></li><li><a href="global.html#getTags">getTags</a></li><li><a href="global.html#getTrashFolderOfLastAccount">getTrashFolderOfLastAccount</a></li><li><a href="global.html#getUnsortedFolder">getUnsortedFolder</a></li><li><a href="global.html#getUnsortedMails">getUnsortedMails</a></li><li><a href="global.html#hasAttachment">hasAttachment</a></li><li><a href="global.html#indexNodesByTags">indexNodesByTags</a></li><li><a href="global.html#initAccounts">initAccounts</a></li><li><a href="global.html#initMainFolder">initMainFolder</a></li><li><a href="global.html#initUnsortedMailsUI">initUnsortedMailsUI</a></li><li><a href="global.html#loadAllPreviouslyCopiedIds">loadAllPreviouslyCopiedIds</a></li><li><a href="global.html#loadAndDisplayNotifications">loadAndDisplayNotifications</a></li><li><a href="global.html#loadCopiedMailIds">loadCopiedMailIds</a></li><li><a href="global.html#mailSort">mailSort</a></li><li><a href="global.html#moveMailToFolder">moveMailToFolder</a></li><li><a href="global.html#onStartCopy">onStartCopy</a></li><li><a href="global.html#resetMindMap">resetMindMap</a></li><li><a href="global.html#saveCopiedMailId">saveCopiedMailId</a></li><li><a href="global.html#saveMindMap">saveMindMap</a></li><li><a href="global.html#storeNotification">storeNotification</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Tue May 27 2025 22:04:55 GMT+0200 (heure dâ€™Ã©tÃ© dâ€™Europe centrale)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
